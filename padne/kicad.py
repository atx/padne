
import warnings
# This is to suppress pcbnew deprecation warning. Unfortunately the RPC API
# is not yet cooked enough for us
warnings.simplefilter("ignore", DeprecationWarning)

import enum
import pcbnew
import tempfile
import shapely
import pygerber.gerber.api
import pathlib

from dataclasses import dataclass
from pathlib import Path
from typing import Any, Mapping

import padne.problem as problem

# This file is responsible for loading KiCad files and converting them to our
# internal representation. The idea is that we:
# 1. Load the KiCad file using the KiCad Python API.
# 2. Render it into Shapely objects.
# 3. This needs to include vertex information that

# Hmm, we need to like pick: either we render everything ourselves (fuck)
# or we use pygerber to extract the mesh from gerber files generated by
# KiCad. This has an issue that stuff like vias are not going to be modeled
# well. But, as a first approximation maybe good?
# We can always implement our own renderer later. Or we can start by patching the
# gerber-generated rendered files
# One of the main issues is that we do not have informations about pad center points
# But we can fairly easily compute them and have a lot of work done for us
# by using the gerber pathway


@dataclass(frozen=True)
class LumpedSpec:
    """
    This is what comes out of the eeschema parser (which does not yet exist)
    """

    @dataclass(frozen=True)
    class Endpoint:
        designator: str
        pad: str

    endpoint_a: Endpoint
    endpoint_b: Endpoint

    # Use the unified lumped type from the problem module.
    type: problem.Lumped.Type
    value: float


@dataclass(frozen=True)
class LayerSpec:
    """
    This class contains material parameters for a layer.
    """
    name: str
    resistivity: float


@dataclass(frozen=True)
class ParsedDirective:
    key: str
    params: list[str]

    @classmethod
    def from_string(cls, directive: str) -> 'ParsedDirective':
        tokens = directive.split()
        if len(tokens) < 2:
            raise ValueError(f"Directive must have at least 1 token: {directive}")
        if tokens[0] != "!padne":
            raise ValueError(f"Directive must start with '!padne': {directive}")
        return cls(key=tokens[1], params=tokens[2:])


@dataclass(frozen=True)
class Directives:
    # Surface resistivity
    # TODO: Add default value for 1oz copper
    layers: list[LayerSpec]
    lumpeds: list[LumpedSpec]


def parse_lumped_spec_directive(directive: ParsedDirective) -> LumpedSpec:

    if len(directive.params) != 3:
        raise ValueError(f"Invalid directive format: {directive}")

    try:
        type_enum = problem.Lumped.Type(directive.key)
    except ValueError:
        raise ValueError(f"Unknown directive type: {directive.key}")

    value = parse_value(directive.params[0])
    ep_a = parse_endpoint(directive.params[1])
    ep_b = parse_endpoint(directive.params[2])

    return LumpedSpec(
        endpoint_a=ep_a,
        endpoint_b=ep_b,
        type=type_enum,
        value=value
    )


def process_directives(directives: list[ParsedDirective]) -> Directives:
    layers = []
    lumpeds = []

    for directive in directives:
        match directive.key:
            case "VOLTAGE" | "CURRENT" | "RESISTANCE":
                lumped = parse_lumped_spec_directive(directive)
                lumpeds.append(lumped)
            case "LAYER":
                layer = parse_layer_spec_directive(directive)
                layers.append(layer)
            case _:
                warnings.warn(f"Unknown directive: {directive.key}")

    return Directives(layers=layers, lumpeds=lumpeds)


def parse_layer_spec_directive(directive: ParsedDirective) -> LayerSpec:
    # Parse a directive like
    # !padne LAYER F.Cu 1.68e-8
    # Expected directive format:
    # "!padne LAYER <LAYER_NAME> <RESISTIVITY>"
    # Examples:
    #   "!padne LAYER F.Cu 1.68e-8"
    # TODO: Also implement stuff like "1oz copper"

    if len(directive.params) < 2:
        raise ValueError(f"LAYER directive must have at least 2 parameters (layer name and resistivity): {directive}")
    
    layer_name = directive.params[0]
    resistivity = float(directive.params[1])
    return LayerSpec(name=layer_name, resistivity=resistivity)


def parse_value(value_str: str) -> float:
    """
    Parse a value string that may contain a unit suffix.
    For instance, "5V" becomes 5.0 and "1k" becomes 1000.0.
    """
    multiplier = 1.0
    lower_value = value_str.lower()
    if lower_value.endswith('k'):
        multiplier = 1e3
        value_str = value_str[:-1]
    elif lower_value.endswith('v') or lower_value.endswith('a'):
        value_str = value_str[:-1]
    
    return float(value_str) * multiplier


def parse_endpoint(token: str) -> LumpedSpec.Endpoint:
    """
    Parse an endpoint in the format DESIGNATOR.PAD.
    For example, "R1.1" will become Endpoint(designator="R1", pad="1").
    """
    parts = token.split(".")
    if len(parts) != 2:
        raise ValueError(f"Invalid endpoint format: {token}")
    return LumpedSpec.Endpoint(designator=parts[0], pad=parts[1])


def find_associated_files(pro_file_path: pathlib.Path) -> tuple[Path, Path]:
    """
    Given a KiCad project file, return the associated PCB and schematic file paths.
    
    Args:
        pro_file_path: The KiCad project file (*.kicad_pro)
        
    Returns:
        A tuple of (pcb_file_path, sch_file_path)
    """
    base_name = pro_file_path.stem
    pcb_file_path = pro_file_path.parent / f"{base_name}.kicad_pcb"
    sch_file_path = pro_file_path.parent / f"{base_name}.kicad_sch"
    return pcb_file_path, sch_file_path


def extract_directives_from_eeschema(sch_file_path: pathlib.Path) -> list[str]:
    # First load the input schematic file
    with open(sch_file_path, "r") as f:
        import sexpdata
        sexpr = sexpdata.load(f)

    def find_text_elements(sexp_data):
        # Recurse to find all (text ...) elements in the sexp tree
        # This might be overkill, since I think they only live at the
        # top level
        if not isinstance(sexp_data, list):
            return []

        ret = []

        if len(sexp_data) > 0 and sexp_data[0] == sexpdata.Symbol("text"):
            ret.append(sexp_data)

        for item in sexp_data:
            ret.extend(find_text_elements(item))

        return ret

    def extract_content_from_text_element(text_element):
        assert isinstance(text_element, list)
        assert text_element[0] == sexpdata.Symbol("text")
        # This should probably always be the second element
        return text_element[1]

    all_texts = [
        extract_content_from_text_element(text_element)
        for text_element in find_text_elements(sexpr)
    ]

    directives = [
        ParsedDirective.from_string(text)
        for text in all_texts
        if text.startswith("!padne")
    ]

    return directives


@dataclass(frozen=True)
class PlottedGerberLayer:
    name: str
    layer_id: int
    geometry: shapely.geometry.MultiPolygon


def render_gerbers_from_kicad(pcb_file_path: pathlib.Path) -> list[PlottedGerberLayer]:
    """
    Generate Gerber files from a KiCad PCB file and convert them to PlottedGerberLayer objects.
    
    Args:
        pcb_file_path: Path to the KiCad PCB file
        
    Returns:
        List of PlottedGerberLayer objects containing layer geometries
    """
    with tempfile.TemporaryDirectory() as tmpdir:
        board = pcbnew.LoadBoard(str(pcb_file_path))
        
        # Plot gerbers and get paths to generated files
        gerber_layers = plot_board_to_gerbers(board, Path(tmpdir))
        
        # Extract geometry from gerber files
        return extract_layers_from_gerbers(board, gerber_layers)


def plot_board_to_gerbers(board, output_dir: Path) -> dict[int, Path]:
    """
    Plot copper layers of a KiCad board to Gerber files.
    
    Args:
        board: KiCad board object
        output_dir: Directory where Gerber files will be saved
        
    Returns:
        Dictionary mapping layer IDs to paths of generated Gerber files
    """
    # Create plot controller and options
    plot_controller = pcbnew.PLOT_CONTROLLER(board)
    plot_options = plot_controller.GetPlotOptions()
    
    # Configure plot options for Gerber output
    plot_options.SetOutputDirectory(str(output_dir))
    plot_options.SetFormat(pcbnew.PLOT_FORMAT_GERBER)
    plot_options.SetUseGerberAttributes(True)
    plot_options.SetCreateGerberJobFile(False)
    #plot_options.SetExcludeEdgeLayer(False) # TODO: Figure this out
    plot_options.SetUseAuxOrigin(True)
    # TODO: This is a rather important choice - for now, we make no drill
    # shapes and later after we get via sim online, we need to include the drill shape
    # and handle the edge of each hole correctly
    plot_options.SetDrillMarksType(pcbnew.DRILL_MARKS_FULL_DRILL_SHAPE)
    
    # Set up layer list to plot
    gerber_layers = {}
    
    # Plot each copper layer
    for layer_id in range(pcbnew.PCB_LAYER_ID_COUNT):
        # Get layer name first
        layer_name = board.GetLayerName(layer_id)
        # Only process enabled layers that are copper layers (e.g. contain "Cu")
        if not board.IsLayerEnabled(layer_id) or "Cu" not in layer_name:
            continue
        
        # Open plot file
        plot_controller.SetLayer(layer_id)
        plot_controller.OpenPlotfile(layer_name, pcbnew.PLOT_FORMAT_GERBER, "")
        
        # Plot the layer
        assert plot_controller.PlotLayer(), f"Failed to plot layer {layer_name}"

        gerber_path = Path(plot_controller.GetPlotFileName())

        assert gerber_path.exists(), f"Gerber file {gerber_path} does not exist"

        gerber_layers[layer_id] = gerber_path

    # Close the plot
    plot_controller.ClosePlot()
    
    return gerber_layers


def extract_layers_from_gerbers(board, gerber_layers: dict[int, Path]) -> list[PlottedGerberLayer]:
    """
    Extract geometry from Gerber files and create PlottedGerberLayer objects.
    
    Args:
        board: KiCad board object (for layer names)
        gerber_layers: Dictionary mapping layer IDs to paths of Gerber files
        
    Returns:
        List of PlottedGerberLayer objects
    """
    plotted_layers = []
    
    for layer_id, gerber_path in gerber_layers.items():
        # Get layer name from the board
        layer_name = board.GetLayerName(layer_id)

        # Load gerber file and extract geometry
        gerber_data = pygerber.gerber.api.GerberFile.from_file(gerber_path)
        try:
            geometry = gerber_data.render_with_shapely()._result.shape
        except AssertionError:
            # This is a bug in pygerber, which gets triggered if the
            # gerber file is empty. We should fix this in pygerber ideally
            # TODO: Figure out if there is at least a way to check if the
            # gerber file is empty before we try to render it
            continue

        # Create a PlottedGerberLayer object
        plotted_layer = PlottedGerberLayer(
            name=layer_name,
            layer_id=layer_id,
            geometry=geometry
        )
        
        plotted_layers.append(plotted_layer)
    
    return plotted_layers


def find_pad_location(board, designator: str, pad: str) -> tuple[str, shapely.geometry.Point]:
    """
    Find the physical location of a pad on the PCB.
    
    Args:
        board: KiCad board object
        designator: Component reference designator (e.g., "R1")
        pad: Pad number or name (e.g., "1")
        
    Returns:
        Tuple of (layer_name, point) where point is the pad's center
        
    Raises:
        ValueError: If the component or pad is not found
    """
    # Find the footprint with the given designator
    for footprint in board.GetFootprints():
        if footprint.GetReference() != designator:
            continue
        # Find the pad with the given number/name
        for pad_obj in footprint.Pads():
            if pad_obj.GetName() != pad:
                continue

            # Get the pad's position (in KiCad internal units, nanometers)
            position = pad_obj.GetPosition()
            
            # Convert from KiCad internal units (nanometers) to mm
            x_mm = position.x / 1000000.0
            y_mm = position.y / 1000000.0
            point = shapely.geometry.Point(x_mm, y_mm)
            
            # For SMD pads, get the layer directly
            if pad_obj.GetAttribute() == pcbnew.PAD_ATTRIB_SMD:
                layer_id = pad_obj.GetLayer()
                layer_name = board.GetLayerName(layer_id)
                return layer_name, point
            
            # For through-hole pads, use the component's layer
            # This is a simplification - through-hole pads exist on multiple layers
            # For now, we do not handle this case
            layer_id = footprint.GetLayer()
            layer_name = board.GetLayerName(layer_id)
            return layer_name, point
        
        raise ValueError(f"Pad {pad} not found on component {designator}")
    
    raise ValueError(f"Component {designator} not found")


def load_kicad_project(pro_file_path: pathlib.Path) -> problem.Problem:
    """
    Load a KiCad project and create a Problem object for PDN simulation.
    
    Args:
        pro_file_path: Path to the KiCad project file (*.kicad_pro)
        
    Returns:
        A Problem object containing layers and lumped elements
    
    Raises:
        FileNotFoundError: If required files are missing
        ValueError: If the project contains invalid data
    """
    # Verify project file exists
    if not pro_file_path.exists():
        raise FileNotFoundError(f"Project file not found: {pro_file_path}")
    
    # Find associated PCB and schematic files
    pcb_file_path, sch_file_path = find_associated_files(pro_file_path)
    
    # Verify required files exist
    if not pcb_file_path.exists():
        raise FileNotFoundError(f"PCB file not found: {pcb_file_path}")
    if not sch_file_path.exists():
        raise FileNotFoundError(f"Schematic file not found: {sch_file_path}")
    
    # Load KiCad board
    board = pcbnew.LoadBoard(str(pcb_file_path))
    
    # Extract layer geometry from PCB file
    plotted_layers = render_gerbers_from_kicad(pcb_file_path)
    
    # Extract directives from schematic
    directives = process_directives(extract_directives_from_eeschema(sch_file_path))
    
    # Create a dictionary of layer resistivities from directives
    layer_resistivity_dict = {}
    default_resistivity = 1.68e-8  # Default copper resistivity
    
    # Populate the dictionary from layer directives
    for layer_spec in directives.layers:
        layer_resistivity_dict[layer_spec.name] = layer_spec.resistivity
    
    # Create a dictionary mapping layer names to Layer objects
    layer_dict = {}
    for plotted_layer in plotted_layers:
        # Use layer-specific resistivity if available, or default
        resistivity = layer_resistivity_dict.get(plotted_layer.name, default_resistivity)
        
        layer = problem.Layer(
            shape=plotted_layer.geometry,
            name=plotted_layer.name,
            resistivity=resistivity
        )
        layer_dict[plotted_layer.name] = layer
    
    # Convert LumpedSpec objects to Lumped objects
    lumpeds = []
    for spec in directives.lumpeds:
        # Find the physical locations of the pads
        a_layer_name, a_point = find_pad_location(
            board, spec.endpoint_a.designator, spec.endpoint_a.pad
        )
        b_layer_name, b_point = find_pad_location(
            board, spec.endpoint_b.designator, spec.endpoint_b.pad
        )
        
        # Get the corresponding Layer objects
        if a_layer_name not in layer_dict:
            raise ValueError(f"Layer {a_layer_name} not found in rendered layers")
        if b_layer_name not in layer_dict:
            raise ValueError(f"Layer {b_layer_name} not found in rendered layers")
        
        a_layer = layer_dict[a_layer_name]
        b_layer = layer_dict[b_layer_name]
        
        # Create Lumped object
        lumped = problem.Lumped(
            type=spec.type,
            a_layer=a_layer,
            a_point=a_point,
            b_layer=b_layer,
            b_point=b_point,
            value=spec.value
        )
        
        lumpeds.append(lumped)

    # Get all layers as a list
    layers = list(layer_dict.values())
    
    # Return the Problem object
    return problem.Problem(layers=layers, lumpeds=lumpeds)
